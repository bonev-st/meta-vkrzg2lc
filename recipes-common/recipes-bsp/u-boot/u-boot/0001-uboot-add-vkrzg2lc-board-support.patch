From b9432685a93c583cc3c29708414dca9198783886 Mon Sep 17 00:00:00 2001
From: dtodoroff <d.todorov@vekatech.com>
Date: Wed, 22 Nov 2023 11:15:40 +0200
Subject: [PATCH] add vkrzg2lc board support

---
 arch/arm/dts/Makefile              |   3 +-
 arch/arm/dts/vkrzg2lc.dts          | 156 ++++++
 arch/arm/mach-rmobile/Kconfig.64   |   6 +
 board/renesas/vkrzg2lc/Kconfig     |  25 +
 board/renesas/vkrzg2lc/Makefile    |  14 +
 board/renesas/vkrzg2lc/pfc_regs.h  | 733 +++++++++++++++++++++++++++++
 board/renesas/vkrzg2lc/vkrzg2lc.c  | 296 ++++++++++++
 cmd/Kconfig                        |   8 +
 cmd/Makefile                       |   1 +
 cmd/cm33.c                         | 131 ++++++
 configs/vkrzg2lc-sf_defconfig      | 106 +++++
 configs/vkrzg2lc_defconfig         | 107 +++++
 drivers/mtd/spi/spi-nor-ids.c      |   4 +-
 drivers/net/phy/realtek.c          |   1 +
 include/configs/vkrzg2lc.h         | 161 +++++++
 include/configs/vkrzg2lc_overlay.h |  75 +++
 16 files changed, 1824 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/dts/vkrzg2lc.dts
 create mode 100644 board/renesas/vkrzg2lc/Kconfig
 create mode 100644 board/renesas/vkrzg2lc/Makefile
 create mode 100644 board/renesas/vkrzg2lc/pfc_regs.h
 create mode 100644 board/renesas/vkrzg2lc/vkrzg2lc.c
 create mode 100644 cmd/cm33.c
 create mode 100644 configs/vkrzg2lc-sf_defconfig
 create mode 100644 configs/vkrzg2lc_defconfig
 create mode 100644 include/configs/vkrzg2lc.h
 create mode 100644 include/configs/vkrzg2lc_overlay.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 459ed9108a..22e50d4cae 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -931,7 +931,8 @@ dtb-$(CONFIG_RCAR_GEN3) += \
 	rzg2ul-type1-dev.dtb \
 	rzg2ul-type1-ddr3l-dev.dtb \
 	rzg2ul-type2-dev.dtb \
-	smarc-rzg2ul.dtb 
+	smarc-rzg2ul.dtb \
+        vkrzg2lc.dtb
 
 ifdef CONFIG_RCAR_GEN3
 DTC_FLAGS += -R 4 -p 0x1000
diff --git a/arch/arm/dts/vkrzg2lc.dts b/arch/arm/dts/vkrzg2lc.dts
new file mode 100644
index 0000000000..a191c74766
--- /dev/null
+++ b/arch/arm/dts/vkrzg2lc.dts
@@ -0,0 +1,156 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-RZG2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkrzg2lc";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>; 
+                /*reg = <0 0x48000000 0 0x38000000>; */ 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZG2L_PINMUX(18, 0, 3)>,
+                         <RZG2L_PINMUX(18, 1, 3)>;
+        }; 
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P4_1.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/mach-rmobile/Kconfig.64 b/arch/arm/mach-rmobile/Kconfig.64
index e6a3096e97..dc761d1f3d 100644
--- a/arch/arm/mach-rmobile/Kconfig.64
+++ b/arch/arm/mach-rmobile/Kconfig.64
@@ -197,6 +197,11 @@ config TARGET_RZG2LC_DEV
 	help
           Support for Renesas RZ/G2LC Dev Platform
 
+config TARGET_VKRZG2LC
+        bool "Vekatech VK-RZ/G2LC Board "
+        help
+          Support for Vekatech VK-RZ/G2LC Board
+
 config TARGET_SMARC_RZG2LC
 	bool "RZ/G2LC SMARC board"
 	help
@@ -241,6 +246,7 @@ source "board/renesas/rzg2l-dev/Kconfig"
 source "board/renesas/rzv2l-dev/Kconfig"
 source "board/renesas/rzg2lc-dev/Kconfig"
 source "board/renesas/rzg2ul-dev/Kconfig"
+source "board/renesas/vkrzg2lc/Kconfig"
 
 config MULTI_DTB_FIT_UNCOMPRESS_SZ
 	default 0x80000 if TARGET_HIHOPE_RZG2
diff --git a/board/renesas/vkrzg2lc/Kconfig b/board/renesas/vkrzg2lc/Kconfig
new file mode 100644
index 0000000000..0c51edbee5
--- /dev/null
+++ b/board/renesas/vkrzg2lc/Kconfig
@@ -0,0 +1,25 @@
+if TARGET_VKRZG2LC
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkrzg2lc"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkrzg2lc"
+
+config SYS_MMC_DEV
+	int
+	default 1 if ENV_IS_IN_SPI_FLASH
+	default 0
+
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+endif
+
diff --git a/board/renesas/vkrzg2lc/Makefile b/board/renesas/vkrzg2lc/Makefile
new file mode 100644
index 0000000000..5bed883b27
--- /dev/null
+++ b/board/renesas/vkrzg2lc/Makefile
@@ -0,0 +1,14 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	+= vkrzg2lc.o
+obj-y	+= ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkrzg2lc/pfc_regs.h b/board/renesas/vkrzg2lc/pfc_regs.h
new file mode 100644
index 0000000000..d3edc54855
--- /dev/null
+++ b/board/renesas/vkrzg2lc/pfc_regs.h
@@ -0,0 +1,733 @@
+/*
+ * Copyright (c) 2020-2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __PFC_REGS_H__
+#define __PFC_REGS_H__
+
+#define	PFC_BASE					(0x11030000)			/* PFC base address */
+
+#define PFC_P10							(PFC_BASE + 0x0010)	/* Port register */
+#define PFC_P11							(PFC_BASE + 0x0011)	/* Port register */
+#define PFC_P12							(PFC_BASE + 0x0012)	/* Port register */
+#define PFC_P13							(PFC_BASE + 0x0013)	/* Port register */
+#define PFC_P14							(PFC_BASE + 0x0014)	/* Port register */
+#define PFC_P15							(PFC_BASE + 0x0015)	/* Port register */
+#define PFC_P16							(PFC_BASE + 0x0016)	/* Port register */
+#define PFC_P17							(PFC_BASE + 0x0017)	/* Port register */
+#define PFC_P18							(PFC_BASE + 0x0018)	/* Port register */
+#define PFC_P19							(PFC_BASE + 0x0019)	/* Port register */
+#define PFC_P1A							(PFC_BASE + 0x001A)	/* Port register */
+#define PFC_P1B							(PFC_BASE + 0x001B)	/* Port register */
+#define PFC_P1C							(PFC_BASE + 0x001C)	/* Port register */
+#define PFC_P1D							(PFC_BASE + 0x001D)	/* Port register */
+#define PFC_P1E							(PFC_BASE + 0x001E)	/* Port register */
+#define PFC_P1F							(PFC_BASE + 0x001F)	/* Port register */
+#define PFC_P20							(PFC_BASE + 0x0020)	/* Port register */
+#define PFC_P21							(PFC_BASE + 0x0021)	/* Port register */
+#define PFC_P22							(PFC_BASE + 0x0022)	/* Port register */
+#define PFC_P23							(PFC_BASE + 0x0023)	/* Port register */
+#define PFC_P24							(PFC_BASE + 0x0024)	/* Port register */
+#define PFC_P25							(PFC_BASE + 0x0025)	/* Port register */
+#define PFC_P26							(PFC_BASE + 0x0026)	/* Port register */
+#define PFC_P27							(PFC_BASE + 0x0027)	/* Port register */
+#define PFC_P28							(PFC_BASE + 0x0028)	/* Port register */
+#define PFC_P29							(PFC_BASE + 0x0029)	/* Port register */
+#define PFC_P2A							(PFC_BASE + 0x002A)	/* Port register */
+#define PFC_P2B							(PFC_BASE + 0x002B)	/* Port register */
+#define PFC_P2C							(PFC_BASE + 0x002C)	/* Port register */
+#define PFC_P2D							(PFC_BASE + 0x002D)	/* Port register */
+#define PFC_P2E							(PFC_BASE + 0x002E)	/* Port register */
+#define PFC_P2F							(PFC_BASE + 0x002F)	/* Port register */
+#define PFC_P30							(PFC_BASE + 0x0030)	/* Port register */
+#define PFC_P31							(PFC_BASE + 0x0031)	/* Port register */
+#define PFC_P32							(PFC_BASE + 0x0032)	/* Port register */
+#define PFC_P33							(PFC_BASE + 0x0033)	/* Port register */
+#define PFC_P34							(PFC_BASE + 0x0034)	/* Port register */
+#define PFC_P35							(PFC_BASE + 0x0035)	/* Port register */
+#define PFC_P36							(PFC_BASE + 0x0036)	/* Port register */
+#define PFC_P37							(PFC_BASE + 0x0037)	/* Port register */
+#define PFC_P38							(PFC_BASE + 0x0038)	/* Port register */
+#define PFC_P39							(PFC_BASE + 0x0039)	/* Port register */
+#define PFC_P3A							(PFC_BASE + 0x003A)	/* Port register */
+#define PFC_P3B							(PFC_BASE + 0x003B)	/* Port register */
+#define PFC_P3C							(PFC_BASE + 0x003C)	/* Port register */
+#define PFC_P3D							(PFC_BASE + 0x003D)	/* Port register */
+#define PFC_P3E							(PFC_BASE + 0x003E)	/* Port register */
+#define PFC_P3F							(PFC_BASE + 0x003F)	/* Port register */
+#define PFC_P40							(PFC_BASE + 0x0040)	/* Port register */
+#define PFC_PM10						(PFC_BASE + 0x0120)	/* Port mode register */
+#define PFC_PM11						(PFC_BASE + 0x0122)	/* Port mode register */
+#define PFC_PM12						(PFC_BASE + 0x0124)	/* Port mode register */
+#define PFC_PM13						(PFC_BASE + 0x0126)	/* Port mode register */
+#define PFC_PM14						(PFC_BASE + 0x0128)	/* Port mode register */
+#define PFC_PM15						(PFC_BASE + 0x012A)	/* Port mode register */
+#define PFC_PM16						(PFC_BASE + 0x012C)	/* Port mode register */
+#define PFC_PM17						(PFC_BASE + 0x012E)	/* Port mode register */
+#define PFC_PM18						(PFC_BASE + 0x0130)	/* Port mode register */
+#define PFC_PM19						(PFC_BASE + 0x0132)	/* Port mode register */
+#define PFC_PM1A						(PFC_BASE + 0x0134)	/* Port mode register */
+#define PFC_PM1B						(PFC_BASE + 0x0136)	/* Port mode register */
+#define PFC_PM1C						(PFC_BASE + 0x0138)	/* Port mode register */
+#define PFC_PM1D						(PFC_BASE + 0x013A)	/* Port mode register */
+#define PFC_PM1E						(PFC_BASE + 0x013C)	/* Port mode register */
+#define PFC_PM1F						(PFC_BASE + 0x013E)	/* Port mode register */
+#define PFC_PM20						(PFC_BASE + 0x0140)	/* Port mode register */
+#define PFC_PM21						(PFC_BASE + 0x0142)	/* Port mode register */
+#define PFC_PM22						(PFC_BASE + 0x0144)	/* Port mode register */
+#define PFC_PM23						(PFC_BASE + 0x0146)	/* Port mode register */
+#define PFC_PM24						(PFC_BASE + 0x0148)	/* Port mode register */
+#define PFC_PM25						(PFC_BASE + 0x014A)	/* Port mode register */
+#define PFC_PM26						(PFC_BASE + 0x014C)	/* Port mode register */
+#define PFC_PM27						(PFC_BASE + 0x014E)	/* Port mode register */
+#define PFC_PM28						(PFC_BASE + 0x0150)	/* Port mode register */
+#define PFC_PM29						(PFC_BASE + 0x0152)	/* Port mode register */
+#define PFC_PM2A						(PFC_BASE + 0x0154)	/* Port mode register */
+#define PFC_PM2B						(PFC_BASE + 0x0156)	/* Port mode register */
+#define PFC_PM2C						(PFC_BASE + 0x0158)	/* Port mode register */
+#define PFC_PM2D						(PFC_BASE + 0x015A)	/* Port mode register */
+#define PFC_PM2E						(PFC_BASE + 0x015C)	/* Port mode register */
+#define PFC_PM2F						(PFC_BASE + 0x015E)	/* Port mode register */
+#define PFC_PM30						(PFC_BASE + 0x0160)	/* Port mode register */
+#define PFC_PM31						(PFC_BASE + 0x0162)	/* Port mode register */
+#define PFC_PM32						(PFC_BASE + 0x0164)	/* Port mode register */
+#define PFC_PM33						(PFC_BASE + 0x0166)	/* Port mode register */
+#define PFC_PM34						(PFC_BASE + 0x0168)	/* Port mode register */
+#define PFC_PM35						(PFC_BASE + 0x016A)	/* Port mode register */
+#define PFC_PM36						(PFC_BASE + 0x016C)	/* Port mode register */
+#define PFC_PM37						(PFC_BASE + 0x016E)	/* Port mode register */
+#define PFC_PM38						(PFC_BASE + 0x0170)	/* Port mode register */
+#define PFC_PM39						(PFC_BASE + 0x0172)	/* Port mode register */
+#define PFC_PM3A						(PFC_BASE + 0x0174)	/* Port mode register */
+#define PFC_PM3B						(PFC_BASE + 0x0176)	/* Port mode register */
+#define PFC_PM3C						(PFC_BASE + 0x0178)	/* Port mode register */
+#define PFC_PM3D						(PFC_BASE + 0x017A)	/* Port mode register */
+#define PFC_PM3E						(PFC_BASE + 0x017C)	/* Port mode register */
+#define PFC_PM3F						(PFC_BASE + 0x017E)	/* Port mode register */
+#define PFC_PM40						(PFC_BASE + 0x0180)	/* Port mode register */
+#define PFC_PMC10						(PFC_BASE + 0x0210)	/* Port mode control register */
+#define PFC_PMC11						(PFC_BASE + 0x0211)	/* Port mode control register */
+#define PFC_PMC12						(PFC_BASE + 0x0212)	/* Port mode control register */
+#define PFC_PMC13						(PFC_BASE + 0x0213)	/* Port mode control register */
+#define PFC_PMC14						(PFC_BASE + 0x0214)	/* Port mode control register */
+#define PFC_PMC15						(PFC_BASE + 0x0215)	/* Port mode control register */
+#define PFC_PMC16						(PFC_BASE + 0x0216)	/* Port mode control register */
+#define PFC_PMC17						(PFC_BASE + 0x0217)	/* Port mode control register */
+#define PFC_PMC18						(PFC_BASE + 0x0218)	/* Port mode control register */
+#define PFC_PMC19						(PFC_BASE + 0x0219)	/* Port mode control register */
+#define PFC_PMC1A						(PFC_BASE + 0x021A)	/* Port mode control register */
+#define PFC_PMC1B						(PFC_BASE + 0x021B)	/* Port mode control register */
+#define PFC_PMC1C						(PFC_BASE + 0x021C)	/* Port mode control register */
+#define PFC_PMC1D						(PFC_BASE + 0x021D)	/* Port mode control register */
+#define PFC_PMC1E						(PFC_BASE + 0x021E)	/* Port mode control register */
+#define PFC_PMC1F						(PFC_BASE + 0x021F)	/* Port mode control register */
+#define PFC_PMC20						(PFC_BASE + 0x0220)	/* Port mode control register */
+#define PFC_PMC21						(PFC_BASE + 0x0221)	/* Port mode control register */
+#define PFC_PMC22						(PFC_BASE + 0x0222)	/* Port mode control register */
+#define PFC_PMC23						(PFC_BASE + 0x0223)	/* Port mode control register */
+#define PFC_PMC24						(PFC_BASE + 0x0224)	/* Port mode control register */
+#define PFC_PMC25						(PFC_BASE + 0x0225)	/* Port mode control register */
+#define PFC_PMC26						(PFC_BASE + 0x0226)	/* Port mode control register */
+#define PFC_PMC27						(PFC_BASE + 0x0227)	/* Port mode control register */
+#define PFC_PMC28						(PFC_BASE + 0x0228)	/* Port mode control register */
+#define PFC_PMC29						(PFC_BASE + 0x0229)	/* Port mode control register */
+#define PFC_PMC2A						(PFC_BASE + 0x022A)	/* Port mode control register */
+#define PFC_PMC2B						(PFC_BASE + 0x022B)	/* Port mode control register */
+#define PFC_PMC2C						(PFC_BASE + 0x022C)	/* Port mode control register */
+#define PFC_PMC2D						(PFC_BASE + 0x022D)	/* Port mode control register */
+#define PFC_PMC2E						(PFC_BASE + 0x022E)	/* Port mode control register */
+#define PFC_PMC2F						(PFC_BASE + 0x022F)	/* Port mode control register */
+#define PFC_PMC30						(PFC_BASE + 0x0230)	/* Port mode control register */
+#define PFC_PMC31						(PFC_BASE + 0x0231)	/* Port mode control register */
+#define PFC_PMC32						(PFC_BASE + 0x0232)	/* Port mode control register */
+#define PFC_PMC33						(PFC_BASE + 0x0233)	/* Port mode control register */
+#define PFC_PMC34						(PFC_BASE + 0x0234)	/* Port mode control register */
+#define PFC_PMC35						(PFC_BASE + 0x0235)	/* Port mode control register */
+#define PFC_PMC36						(PFC_BASE + 0x0236)	/* Port mode control register */
+#define PFC_PMC37						(PFC_BASE + 0x0237)	/* Port mode control register */
+#define PFC_PMC38						(PFC_BASE + 0x0238)	/* Port mode control register */
+#define PFC_PMC39						(PFC_BASE + 0x0239)	/* Port mode control register */
+#define PFC_PMC3A						(PFC_BASE + 0x023A)	/* Port mode control register */
+#define PFC_PMC3B						(PFC_BASE + 0x023B)	/* Port mode control register */
+#define PFC_PMC3C						(PFC_BASE + 0x023C)	/* Port mode control register */
+#define PFC_PMC3D						(PFC_BASE + 0x023D)	/* Port mode control register */
+#define PFC_PMC3E						(PFC_BASE + 0x023E)	/* Port mode control register */
+#define PFC_PMC3F						(PFC_BASE + 0x023F)	/* Port mode control register */
+#define PFC_PMC40						(PFC_BASE + 0x0240)	/* Port mode control register */
+#define PFC_PFC10						(PFC_BASE + 0x0440)	/* Port function control register */
+#define PFC_PFC11						(PFC_BASE + 0x0444)	/* Port function control register */
+#define PFC_PFC12						(PFC_BASE + 0x0448)	/* Port function control register */
+#define PFC_PFC13						(PFC_BASE + 0x044C)	/* Port function control register */
+#define PFC_PFC14						(PFC_BASE + 0x0450)	/* Port function control register */
+#define PFC_PFC15						(PFC_BASE + 0x0454)	/* Port function control register */
+#define PFC_PFC16						(PFC_BASE + 0x0458)	/* Port function control register */
+#define PFC_PFC17						(PFC_BASE + 0x045C)	/* Port function control register */
+#define PFC_PFC18						(PFC_BASE + 0x0460)	/* Port function control register */
+#define PFC_PFC19						(PFC_BASE + 0x0464)	/* Port function control register */
+#define PFC_PFC1A						(PFC_BASE + 0x0468)	/* Port function control register */
+#define PFC_PFC1B						(PFC_BASE + 0x046C)	/* Port function control register */
+#define PFC_PFC1C						(PFC_BASE + 0x0470)	/* Port function control register */
+#define PFC_PFC1D						(PFC_BASE + 0x0474)	/* Port function control register */
+#define PFC_PFC1E						(PFC_BASE + 0x0478)	/* Port function control register */
+#define PFC_PFC1F						(PFC_BASE + 0x047C)	/* Port function control register */
+#define PFC_PFC20						(PFC_BASE + 0x0480)	/* Port function control register */
+#define PFC_PFC21						(PFC_BASE + 0x0484)	/* Port function control register */
+#define PFC_PFC22						(PFC_BASE + 0x0488)	/* Port function control register */
+#define PFC_PFC23						(PFC_BASE + 0x048C)	/* Port function control register */
+#define PFC_PFC24						(PFC_BASE + 0x0490)	/* Port function control register */
+#define PFC_PFC25						(PFC_BASE + 0x0494)	/* Port function control register */
+#define PFC_PFC26						(PFC_BASE + 0x0498)	/* Port function control register */
+#define PFC_PFC27						(PFC_BASE + 0x049C)	/* Port function control register */
+#define PFC_PFC28						(PFC_BASE + 0x04A0)	/* Port function control register */
+#define PFC_PFC29						(PFC_BASE + 0x04A4)	/* Port function control register */
+#define PFC_PFC2A						(PFC_BASE + 0x04A8)	/* Port function control register */
+#define PFC_PFC2B						(PFC_BASE + 0x04AC)	/* Port function control register */
+#define PFC_PFC2C						(PFC_BASE + 0x04B0)	/* Port function control register */
+#define PFC_PFC2D						(PFC_BASE + 0x04B4)	/* Port function control register */
+#define PFC_PFC2E						(PFC_BASE + 0x04B8)	/* Port function control register */
+#define PFC_PFC2F						(PFC_BASE + 0x04BC)	/* Port function control register */
+#define PFC_PFC30						(PFC_BASE + 0x04C0)	/* Port function control register */
+#define PFC_PFC31						(PFC_BASE + 0x04C4)	/* Port function control register */
+#define PFC_PFC32						(PFC_BASE + 0x04C8)	/* Port function control register */
+#define PFC_PFC33						(PFC_BASE + 0x04CC)	/* Port function control register */
+#define PFC_PFC34						(PFC_BASE + 0x04D0)	/* Port function control register */
+#define PFC_PFC35						(PFC_BASE + 0x04D4)	/* Port function control register */
+#define PFC_PFC36						(PFC_BASE + 0x04D8)	/* Port function control register */
+#define PFC_PFC37						(PFC_BASE + 0x04DC)	/* Port function control register */
+#define PFC_PFC38						(PFC_BASE + 0x04E0)	/* Port function control register */
+#define PFC_PFC39						(PFC_BASE + 0x04E4)	/* Port function control register */
+#define PFC_PFC3A						(PFC_BASE + 0x04E8)	/* Port function control register */
+#define PFC_PFC3B						(PFC_BASE + 0x04EC)	/* Port function control register */
+#define PFC_PFC3C						(PFC_BASE + 0x04F0)	/* Port function control register */
+#define PFC_PFC3D						(PFC_BASE + 0x04F4)	/* Port function control register */
+#define PFC_PFC3E						(PFC_BASE + 0x04F8)	/* Port function control register */
+#define PFC_PFC3F						(PFC_BASE + 0x04FC)	/* Port function control register */
+#define PFC_PFC40						(PFC_BASE + 0x0500)	/* Port function control register */
+#define PFC_IOLH02						(PFC_BASE + 0x1010)	/* IOLH switch register */
+#define PFC_IOLH03						(PFC_BASE + 0x1018)	/* IOLH switch register */
+#define PFC_IOLH06						(PFC_BASE + 0x1030)	/* IOLH switch register */
+#define PFC_IOLH07						(PFC_BASE + 0x1038)	/* IOLH switch register */
+#define PFC_IOLH08						(PFC_BASE + 0x1040)	/* IOLH switch register */
+#define PFC_IOLH09						(PFC_BASE + 0x1048)	/* IOLH switch register */
+#define PFC_IOLH0A						(PFC_BASE + 0x1050)	/* IOLH switch register */
+#define PFC_IOLH0B						(PFC_BASE + 0x1058)	/* IOLH switch register */
+#define PFC_IOLH0C						(PFC_BASE + 0x1060)	/* IOLH switch register */
+#define PFC_IOLH0D						(PFC_BASE + 0x1068)	/* IOLH switch register */
+#define PFC_IOLH10						(PFC_BASE + 0x1080)	/* IOLH switch register */
+#define PFC_IOLH11						(PFC_BASE + 0x1088)	/* IOLH switch register */
+#define PFC_IOLH12						(PFC_BASE + 0x1090)	/* IOLH switch register */
+#define PFC_IOLH13						(PFC_BASE + 0x1098)	/* IOLH switch register */
+#define PFC_IOLH14						(PFC_BASE + 0x10A0)	/* IOLH switch register */
+#define PFC_IOLH15						(PFC_BASE + 0x10A8)	/* IOLH switch register */
+#define PFC_IOLH16						(PFC_BASE + 0x10B0)	/* IOLH switch register */
+#define PFC_IOLH17						(PFC_BASE + 0x10B8)	/* IOLH switch register */
+#define PFC_IOLH18						(PFC_BASE + 0x10C0)	/* IOLH switch register */
+#define PFC_IOLH19						(PFC_BASE + 0x10C8)	/* IOLH switch register */
+#define PFC_IOLH1A						(PFC_BASE + 0x10D0)	/* IOLH switch register */
+#define PFC_IOLH1B						(PFC_BASE + 0x10D8)	/* IOLH switch register */
+#define PFC_IOLH1C						(PFC_BASE + 0x10E0)	/* IOLH switch register */
+#define PFC_IOLH1D						(PFC_BASE + 0x10E8)	/* IOLH switch register */
+#define PFC_IOLH1E						(PFC_BASE + 0x10F0)	/* IOLH switch register */
+#define PFC_IOLH1F						(PFC_BASE + 0x10F8)	/* IOLH switch register */
+#define PFC_IOLH20						(PFC_BASE + 0x1100)	/* IOLH switch register */
+#define PFC_IOLH21						(PFC_BASE + 0x1108)	/* IOLH switch register */
+#define PFC_IOLH22						(PFC_BASE + 0x1120)	/* IOLH switch register */
+#define PFC_IOLH23						(PFC_BASE + 0x1128)	/* IOLH switch register */
+#define PFC_IOLH36						(PFC_BASE + 0x11B0)	/* IOLH switch register */
+#define PFC_IOLH37						(PFC_BASE + 0x11B8)	/* IOLH switch register */
+#define PFC_IOLH38						(PFC_BASE + 0x11C0)	/* IOLH switch register */
+#define PFC_IOLH39						(PFC_BASE + 0x11C8)	/* IOLH switch register */
+#define PFC_IOLH3A						(PFC_BASE + 0x11D0)	/* IOLH switch register */
+#define PFC_IOLH3B						(PFC_BASE + 0x11D8)	/* IOLH switch register */
+#define PFC_IOLH3C						(PFC_BASE + 0x11E0)	/* IOLH switch register */
+#define PFC_IOLH3D						(PFC_BASE + 0x11E8)	/* IOLH switch register */
+#define PFC_IOLH3E						(PFC_BASE + 0x11F0)	/* IOLH switch register */
+#define PFC_IOLH3F						(PFC_BASE + 0x11F8)	/* IOLH switch register */
+#define PFC_IOLH40						(PFC_BASE + 0x1200)	/* IOLH switch register */
+#define PFC_SR06						(PFC_BASE + 0x1430)	/* Slew-Rate switch register */
+#define PFC_SR07						(PFC_BASE + 0x1438)	/* Slew-Rate switch register */
+#define PFC_SR08						(PFC_BASE + 0x1440)	/* Slew-Rate switch register */
+#define PFC_SR09						(PFC_BASE + 0x1448)	/* Slew-Rate switch register */
+#define PFC_SR0A						(PFC_BASE + 0x1450)	/* Slew-Rate switch register */
+#define PFC_SR0B						(PFC_BASE + 0x1458)	/* Slew-Rate switch register */
+#define PFC_SR0C						(PFC_BASE + 0x1460)	/* Slew-Rate switch register */
+#define PFC_SR10						(PFC_BASE + 0x1480)	/* Slew-Rate switch register */
+#define PFC_SR15						(PFC_BASE + 0x14A8)	/* Slew-Rate switch register */
+#define PFC_SR16						(PFC_BASE + 0x14B0)	/* Slew-Rate switch register */
+#define PFC_SR1B						(PFC_BASE + 0x14D8)	/* Slew-Rate switch register */
+#define PFC_SR1C						(PFC_BASE + 0x14E0)	/* Slew-Rate switch register */
+#define PFC_SR1D						(PFC_BASE + 0x14E8)	/* Slew-Rate switch register */
+#define PFC_SR1E						(PFC_BASE + 0x14F0)	/* Slew-Rate switch register */
+#define PFC_SR1F						(PFC_BASE + 0x14F8)	/* Slew-Rate switch register */
+#define PFC_SR20						(PFC_BASE + 0x1500)	/* Slew-Rate switch register */
+#define PFC_SR21						(PFC_BASE + 0x1508)	/* Slew-Rate switch register */
+#define PFC_SR22						(PFC_BASE + 0x1510)	/* Slew-Rate switch register */
+#define PFC_SR23						(PFC_BASE + 0x1518)	/* Slew-Rate switch register */
+#define PFC_SR36						(PFC_BASE + 0x15B0)	/* Slew-Rate switch register */
+#define PFC_SR37						(PFC_BASE + 0x15B8)	/* Slew-Rate switch register */
+#define PFC_IEN06						(PFC_BASE + 0x1830)	/* IEN switch register */
+#define PFC_IEN07						(PFC_BASE + 0x1838)	/* IEN switch register */
+#define PFC_IEN08						(PFC_BASE + 0x1840)	/* IEN switch register */
+#define PFC_IEN09						(PFC_BASE + 0x1848)	/* IEN switch register */
+#define PFC_PUPD06						(PFC_BASE + 0x1C30)	/* PU/PD switch register */
+#define PFC_PUPD07						(PFC_BASE + 0x1C38)	/* PU/PD switch register */
+#define PFC_PUPD08						(PFC_BASE + 0x1C40)	/* PU/PD switch register */
+#define PFC_PUPD09						(PFC_BASE + 0x1C48)	/* PU/PD switch register */
+#define PFC_PUPD0A						(PFC_BASE + 0x1C50)	/* PU/PD switch register */
+#define PFC_PUPD0B						(PFC_BASE + 0x1C58)	/* PU/PD switch register */
+#define PFC_PUPD0C						(PFC_BASE + 0x1C60)	/* PU/PD switch register */
+#define PFC_PUPD10						(PFC_BASE + 0x1C80)	/* PU/PD switch register */
+#define PFC_PUPD15						(PFC_BASE + 0x1CA8)	/* PU/PD switch register */
+#define PFC_PUPD16						(PFC_BASE + 0x1CB0)	/* PU/PD switch register */
+#define PFC_PUPD1B						(PFC_BASE + 0x1CD8)	/* PU/PD switch register */
+#define PFC_PUPD1C						(PFC_BASE + 0x1CE0)	/* PU/PD switch register */
+#define PFC_PUPD1D						(PFC_BASE + 0x1CE8)	/* PU/PD switch register */
+#define PFC_PUPD1E						(PFC_BASE + 0x1CF0)	/* PU/PD switch register */
+#define PFC_PUPD1F						(PFC_BASE + 0x1CF8)	/* PU/PD switch register */
+#define PFC_PUPD20						(PFC_BASE + 0x1D00)	/* PU/PD switch register */
+#define PFC_PUPD21						(PFC_BASE + 0x1D08)	/* PU/PD switch register */
+#define PFC_PUPD22						(PFC_BASE + 0x1D10)	/* PU/PD switch register */
+#define PFC_PUPD23						(PFC_BASE + 0x1D18)	/* PU/PD switch register */
+#define PFC_PUPD36						(PFC_BASE + 0x1DB0)	/* PU/PD switch register */
+#define PFC_PUPD37						(PFC_BASE + 0x1DB8)	/* PU/PD switch register */
+#define PFC_SD_ch0						(PFC_BASE + 0x3000)	/* SD ch0 IO voltage control register */
+#define PFC_SD_ch1						(PFC_BASE + 0x3004)	/* SD ch1 IO voltage control register */
+#define PFC_QSPI						(PFC_BASE + 0x3008)	/* QSPI IO voltage control register */
+#define PFC_ETH_ch0						(PFC_BASE + 0x300C)	/* ETH ch0 voltage control register */
+#define PFC_ETH_ch1						(PFC_BASE + 0x3010)	/* ETH ch1 voltage control register */
+#define PFC_PWPR						(PFC_BASE + 0x3014)	/* Write protect */
+#define PFC_FILONOFF01					(PFC_BASE + 0x2008)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF10					(PFC_BASE + 0x2080)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF11					(PFC_BASE + 0x2088)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF12					(PFC_BASE + 0x2090)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF13					(PFC_BASE + 0x2098)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF14					(PFC_BASE + 0x20A0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF15					(PFC_BASE + 0x20A8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF16					(PFC_BASE + 0x20B0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF17					(PFC_BASE + 0x20B8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF18					(PFC_BASE + 0x20C0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF19					(PFC_BASE + 0x20C8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1A					(PFC_BASE + 0x20D0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1B					(PFC_BASE + 0x20D8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1C					(PFC_BASE + 0x20E0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1D					(PFC_BASE + 0x20E8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1E					(PFC_BASE + 0x20F0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF1F					(PFC_BASE + 0x20F8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF20					(PFC_BASE + 0x2100)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF21					(PFC_BASE + 0x2108)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF22					(PFC_BASE + 0x2110)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF23					(PFC_BASE + 0x2118)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF24					(PFC_BASE + 0x2120)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF25					(PFC_BASE + 0x2128)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF26					(PFC_BASE + 0x2130)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF27					(PFC_BASE + 0x2138)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF28					(PFC_BASE + 0x2140)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF29					(PFC_BASE + 0x2148)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2A					(PFC_BASE + 0x2150)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2B					(PFC_BASE + 0x2158)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2C					(PFC_BASE + 0x2160)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2D					(PFC_BASE + 0x2168)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2E					(PFC_BASE + 0x2170)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF2F					(PFC_BASE + 0x2178)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF30					(PFC_BASE + 0x2180)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF31					(PFC_BASE + 0x2188)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF32					(PFC_BASE + 0x2190)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF33					(PFC_BASE + 0x2198)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF34					(PFC_BASE + 0x21A0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF35					(PFC_BASE + 0x21A8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF36					(PFC_BASE + 0x21B0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF37					(PFC_BASE + 0x21B8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF38					(PFC_BASE + 0x21C0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF39					(PFC_BASE + 0x21C8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3A					(PFC_BASE + 0x21D0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3B					(PFC_BASE + 0x21D8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3C					(PFC_BASE + 0x21E0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3D					(PFC_BASE + 0x21E8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3E					(PFC_BASE + 0x21F0)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF3F					(PFC_BASE + 0x21F8)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILONOFF40					(PFC_BASE + 0x2200)	/* Digital noise filter (FILONOFF) register */
+#define PFC_FILNUM01					(PFC_BASE + 0x2408)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM10					(PFC_BASE + 0x2480)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM11					(PFC_BASE + 0x2488)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM12					(PFC_BASE + 0x2490)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM13					(PFC_BASE + 0x2498)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM14					(PFC_BASE + 0x24A0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM15					(PFC_BASE + 0x24A8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM16					(PFC_BASE + 0x24B0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM17					(PFC_BASE + 0x24B8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM18					(PFC_BASE + 0x24C0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM19					(PFC_BASE + 0x24C8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1A					(PFC_BASE + 0x24D0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1B					(PFC_BASE + 0x24D8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1C					(PFC_BASE + 0x24E0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1D					(PFC_BASE + 0x24E8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1E					(PFC_BASE + 0x24F0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM1F					(PFC_BASE + 0x24F8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM20					(PFC_BASE + 0x2500)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM21					(PFC_BASE + 0x2508)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM22					(PFC_BASE + 0x2510)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM23					(PFC_BASE + 0x2518)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM24					(PFC_BASE + 0x2520)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM25					(PFC_BASE + 0x2528)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM26					(PFC_BASE + 0x2530)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM27					(PFC_BASE + 0x2538)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM28					(PFC_BASE + 0x2540)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM29					(PFC_BASE + 0x2548)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2A					(PFC_BASE + 0x2550)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2B					(PFC_BASE + 0x2558)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2C					(PFC_BASE + 0x2560)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2D					(PFC_BASE + 0x2568)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2E					(PFC_BASE + 0x2570)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM2F					(PFC_BASE + 0x2578)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM30					(PFC_BASE + 0x2580)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM31					(PFC_BASE + 0x2588)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM32					(PFC_BASE + 0x2590)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM33					(PFC_BASE + 0x2598)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM34					(PFC_BASE + 0x25A0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM35					(PFC_BASE + 0x25A8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM36					(PFC_BASE + 0x25B0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM37					(PFC_BASE + 0x25B8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM38					(PFC_BASE + 0x25C0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM39					(PFC_BASE + 0x25C8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3A					(PFC_BASE + 0x25D0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3B					(PFC_BASE + 0x25D8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3C					(PFC_BASE + 0x25E0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3D					(PFC_BASE + 0x25E8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3E					(PFC_BASE + 0x25F0)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM3F					(PFC_BASE + 0x25F8)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILNUM40					(PFC_BASE + 0x2600)	/* Digital noise filter (FILNUM) register */
+#define PFC_FILCLKSEL01					(PFC_BASE + 0x2808)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL10					(PFC_BASE + 0x2880)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL11					(PFC_BASE + 0x2888)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL12					(PFC_BASE + 0x2890)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL13					(PFC_BASE + 0x2898)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL14					(PFC_BASE + 0x28A0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL15					(PFC_BASE + 0x28A8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL16					(PFC_BASE + 0x28B0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL17					(PFC_BASE + 0x28B8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL18					(PFC_BASE + 0x28C0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL19					(PFC_BASE + 0x28C8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1A					(PFC_BASE + 0x28D0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1B					(PFC_BASE + 0x28D8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1C					(PFC_BASE + 0x28E0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1D					(PFC_BASE + 0x28E8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1E					(PFC_BASE + 0x28F0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL1F					(PFC_BASE + 0x28F8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL20					(PFC_BASE + 0x2900)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL21					(PFC_BASE + 0x2908)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL22					(PFC_BASE + 0x2910)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL23					(PFC_BASE + 0x2918)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL24					(PFC_BASE + 0x2920)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL25					(PFC_BASE + 0x2928)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL26					(PFC_BASE + 0x2930)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL27					(PFC_BASE + 0x2938)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL28					(PFC_BASE + 0x2940)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL29					(PFC_BASE + 0x2948)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2A					(PFC_BASE + 0x2950)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2B					(PFC_BASE + 0x2958)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2C					(PFC_BASE + 0x2960)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2D					(PFC_BASE + 0x2968)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2E					(PFC_BASE + 0x2970)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL2F					(PFC_BASE + 0x2978)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL30					(PFC_BASE + 0x2980)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL31					(PFC_BASE + 0x2988)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL32					(PFC_BASE + 0x2990)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL33					(PFC_BASE + 0x2998)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL34					(PFC_BASE + 0x29A0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL35					(PFC_BASE + 0x29A8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL36					(PFC_BASE + 0x29B0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL37					(PFC_BASE + 0x29B8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL38					(PFC_BASE + 0x29C0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL39					(PFC_BASE + 0x29C8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3A					(PFC_BASE + 0x29D0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3B					(PFC_BASE + 0x29D8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3C					(PFC_BASE + 0x29E0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3D					(PFC_BASE + 0x29E8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3E					(PFC_BASE + 0x29F0)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL3F					(PFC_BASE + 0x29F8)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_FILCLKSEL40					(PFC_BASE + 0x2A00)	/* Digital noise filter (FILCLKSEL) register */
+#define PFC_ETH_MII						(PFC_BASE + 0x3018)	/* Register for setting the mode of ETH MII / RGMII */
+
+/* Combined terminal setting */
+/* Definition for port register */
+#define P_P0				(1 << 0)
+#define P_P1				(1 << 1)
+#define P_P2				(1 << 2)
+#define P_P3				(1 << 3)
+#define P_P4				(1 << 4)
+#define P_P5				(1 << 5)
+#define P_P6				(1 << 6)
+#define P_P7				(1 << 7)
+/* Definition for port mode register */
+#define PM0_HIZ				(0 << 0)
+#define PM0_IN				(1 << 0)
+#define PM0_OUT_DIS			(2 << 0)
+#define PM0_OUT_EN			(3 << 0)
+#define PM1_HIZ				(0 << 2)
+#define PM1_IN				(1 << 2)
+#define PM1_OUT_DIS			(2 << 2)
+#define PM1_OUT_EN			(3 << 2)
+#define PM2_HIZ				(0 << 4)
+#define PM2_IN				(1 << 4)
+#define PM2_OUT_DIS			(2 << 4)
+#define PM2_OUT_EN			(3 << 4)
+#define PM3_HIZ				(0 << 6)
+#define PM3_IN				(1 << 6)
+#define PM3_OUT_DIS			(2 << 6)
+#define PM3_OUT_EN			(3 << 6)
+#define PM4_HIZ				(0 << 8)
+#define PM4_IN				(1 << 8)
+#define PM4_OUT_DIS			(2 << 8)
+#define PM4_OUT_EN			(3 << 8)
+/* Definition for port mode control register */
+#define PMC_PMC0			(1 << 0)
+#define PMC_PMC1			(1 << 1)
+#define PMC_PMC2			(1 << 2)
+#define PMC_PMC3			(1 << 3)
+#define PMC_PMC4			(1 << 4)
+#define PMC_PMC5			(1 << 5)
+#define PMC_PMC6			(1 << 6)
+#define PMC_PMC7			(1 << 7)
+/* Definition for port function control register */
+#define PFC0_MODE0			(0 << 0)
+#define PFC0_MODE1			(1 << 0)
+#define PFC0_MODE2			(2 << 0)
+#define PFC0_MODE3			(3 << 0)
+#define PFC0_MODE4			(4 << 0)
+#define PFC0_MODE5			(5 << 0)
+#define PFC1_MODE0			(0 << 4)
+#define PFC1_MODE1			(1 << 4)
+#define PFC1_MODE2			(2 << 4)
+#define PFC1_MODE3			(3 << 4)
+#define PFC1_MODE4			(4 << 4)
+#define PFC1_MODE5			(5 << 4)
+#define PFC2_MODE0			(0 << 8)
+#define PFC2_MODE1			(1 << 8)
+#define PFC2_MODE2			(2 << 8)
+#define PFC2_MODE3			(3 << 8)
+#define PFC2_MODE4			(4 << 8)
+#define PFC2_MODE5			(5 << 8)
+#define PFC3_MODE0			(0 << 12)
+#define PFC3_MODE1			(1 << 12)
+#define PFC3_MODE2			(2 << 12)
+#define PFC3_MODE3			(3 << 12)
+#define PFC3_MODE4			(4 << 12)
+#define PFC3_MODE5			(5 << 12)
+#define PFC4_MODE0			(0 << 16)
+#define PFC4_MODE1			(1 << 16)
+#define PFC4_MODE2			(2 << 16)
+#define PFC4_MODE3			(3 << 16)
+#define PFC4_MODE4			(4 << 16)
+#define PFC4_MODE5			(5 << 16)
+/* Definition for IOLH switch register */
+#define IOLH0_2MA			(0 << 0)
+#define IOLH0_4MA			(1 << 0)
+#define IOLH0_8MA			(2 << 0)
+#define IOLH0_12MA			(3 << 0)
+#define IOLH1_2MA			(0 << 8)
+#define IOLH1_4MA			(1 << 8)
+#define IOLH1_8MA			(2 << 8)
+#define IOLH1_12MA			(3 << 8)
+#define IOLH2_2MA			(0 << 16)
+#define IOLH2_4MA			(1 << 16)
+#define IOLH2_8MA			(2 << 16)
+#define IOLH2_12MA			(3 << 16)
+#define IOLH3_2MA			(0 << 24)
+#define IOLH3_4MA			(1 << 24)
+#define IOLH3_8MA			(2 << 24)
+#define IOLH3_12MA			(3 << 24)
+#define IOLH4_2MA			(0 << 32)
+#define IOLH4_4MA			(1 << 32)
+#define IOLH4_8MA			(2 << 32)
+#define IOLH4_12MA			(3 << 32)
+#define IOLH5_2MA			(0 << 40)
+#define IOLH5_4MA			(1 << 40)
+#define IOLH5_8MA			(2 << 40)
+#define IOLH5_12MA			(3 << 40)
+#define IOLH6_2MA			(0 << 48)
+#define IOLH6_4MA			(1 << 48)
+#define IOLH6_8MA			(2 << 48)
+#define IOLH6_12MA			(3 << 48)
+#define IOLH7_2MA			(0 << 56)
+#define IOLH7_4MA			(1 << 56)
+#define IOLH7_8MA			(2 << 56)
+#define IOLH7_12MA			(3 << 56)
+/* Definition for Slew-Rate switch register */
+#define SR0_FAST			(1 << 0)
+#define SR1_FAST			(1 << 8)
+#define SR2_FAST			(1 << 16)
+#define SR3_FAST			(1 << 24)
+#define SR4_FAST			(1 << 32)
+#define SR5_FAST			(1 << 40)
+#define SR6_FAST			(1 << 48)
+#define SR7_FAST			(1 << 56)
+/* Definition for IEN switching register */
+#define IEN0_ENABLE			(1 << 0)
+#define IEN1_ENABLE			(1 << 8)
+#define IEN2_ENABLE			(1 << 16)
+#define IEN3_ENABLE			(1 << 24)
+#define IEN4_ENABLE			(1 << 32)
+#define IEN5_ENABLE			(1 << 40)
+#define IEN6_ENABLE			(1 << 48)
+#define IEN7_ENABLE			(1 << 56)
+/* Definition for PUPD switching register */
+#define PUPD0_NO			(0 << 0)
+#define PUPD0_UP			(1 << 0)
+#define PUPD0_DOWN			(2 << 0)
+#define PUPD1_NO			(0 << 8)
+#define PUPD1_UP			(1 << 8)
+#define PUPD1_DOWN			(2 << 8)
+#define PUPD2_NO			(0 << 16)
+#define PUPD2_UP			(1 << 16)
+#define PUPD2_DOWN			(2 << 16)
+#define PUPD3_NO			(0 << 24)
+#define PUPD3_UP			(1 << 24)
+#define PUPD3_DOWN			(2 << 24)
+#define PUPD4_NO			(0 << 32)
+#define PUPD4_UP			(1 << 32)
+#define PUPD4_DOWN			(2 << 32)
+#define PUPD5_NO			(0 << 40)
+#define PUPD5_UP			(1 << 40)
+#define PUPD5_DOWN			(2 << 40)
+#define PUPD6_NO			(0 << 48)
+#define PUPD6_UP			(1 << 48)
+#define PUPD6_DOWN			(2 << 48)
+#define PUPD7_NO			(0 << 56)
+#define PUPD7_UP			(1 << 56)
+#define PUPD7_DOWN			(2 << 56)
+/* SD ch0 IO Definition for voltage control register */
+#define SD0_PVDD			(1 << 0)
+/* SD ch1 IO Definition for voltage control register */
+#define SD1_PVDD			(1 << 0)
+/* Definition for QSPI IO voltage control register */
+#define QSPI_PVDD			(1 << 0)
+/* ETH ch0 voltage control register */
+#define ETH_ch0_3_3			(0 << 0)
+#define ETH_ch0_1_8			(1 << 0)
+#define ETH_ch0_2_5			(2 << 0)
+/* ETH ch1 voltage control register */
+#define ETH_ch1_3_3			(0 << 0)
+#define ETH_ch1_1_8			(1 << 0)
+#define ETH_ch1_2_5			(2 << 0)
+/* Write protection definition */
+#define PWPR_B0Wl			(1 << 7)
+#define PWPR_PFCWE			(1 << 6)
+/* Digital noise filter (FILONOFF) register */
+#define FILONOFF_FILON0		(1 << 0)
+#define FILONOFF_FILON1		(1 << 8)
+#define FILONOFF_FILON2		(1 << 16)
+#define FILONOFF_FILON3		(1 << 24)
+#define FILONOFF_FILON4		(1 << 32)
+#define FILONOFF_FILON5		(1 << 40)
+#define FILONOFF_FILON6		(1 << 48)
+#define FILONOFF_FILON7		(1 << 56)
+/* Digital noise filter (FILNUM) register */
+#define FILNUM_FILNUM0_4	(0 << 0)
+#define FILNUM_FILNUM0_8	(1 << 0)
+#define FILNUM_FILNUM0_12	(2 << 0)
+#define FILNUM_FILNUM0_16	(3 << 0)
+#define FILNUM_FILNUM1_4	(0 << 8)
+#define FILNUM_FILNUM1_8	(1 << 8)
+#define FILNUM_FILNUM1_12	(2 << 8)
+#define FILNUM_FILNUM1_16	(3 << 8)
+#define FILNUM_FILNUM2_4	(0 << 16)
+#define FILNUM_FILNUM2_8	(1 << 16)
+#define FILNUM_FILNUM2_12	(2 << 16)
+#define FILNUM_FILNUM2_16	(3 << 16)
+#define FILNUM_FILNUM3_4	(0 << 24)
+#define FILNUM_FILNUM3_8	(1 << 24)
+#define FILNUM_FILNUM3_12	(2 << 24)
+#define FILNUM_FILNUM3_16	(3 << 24)
+#define FILNUM_FILNUM4_4	(0 << 32)
+#define FILNUM_FILNUM4_8	(1 << 32)
+#define FILNUM_FILNUM4_12	(2 << 32)
+#define FILNUM_FILNUM4_16	(3 << 32)
+#define FILNUM_FILNUM5_4	(0 << 40)
+#define FILNUM_FILNUM5_8	(1 << 40)
+#define FILNUM_FILNUM5_12	(2 << 40)
+#define FILNUM_FILNUM5_16	(3 << 40)
+#define FILNUM_FILNUM6_4	(0 << 48)
+#define FILNUM_FILNUM6_8	(1 << 48)
+#define FILNUM_FILNUM6_12	(2 << 48)
+#define FILNUM_FILNUM6_16	(3 << 48)
+#define FILNUM_FILNUM7_4	(0 << 56)
+#define FILNUM_FILNUM7_8	(1 << 56)
+#define FILNUM_FILNUM7_12	(2 << 56)
+#define FILNUM_FILNUM7_16	(3 << 56)
+/* Digital noise filter (FILCLKSEL) register */
+#define FILCLKSEL_FILCLK0_0	(0 << 0)
+#define FILCLKSEL_FILCLK0_1	(1 << 0)
+#define FILCLKSEL_FILCLK0_2	(2 << 0)
+#define FILCLKSEL_FILCLK0_3	(3 << 0)
+#define FILCLKSEL_FILCLK1_0	(0 << 8)
+#define FILCLKSEL_FILCLK1_1	(1 << 8)
+#define FILCLKSEL_FILCLK1_2	(2 << 8)
+#define FILCLKSEL_FILCLK1_3	(3 << 8)
+#define FILCLKSEL_FILCLK2_0	(0 << 16)
+#define FILCLKSEL_FILCLK2_1	(1 << 16)
+#define FILCLKSEL_FILCLK2_2	(2 << 16)
+#define FILCLKSEL_FILCLK2_3	(3 << 16)
+#define FILCLKSEL_FILCLK3_0	(0 << 24)
+#define FILCLKSEL_FILCLK3_1	(1 << 24)
+#define FILCLKSEL_FILCLK3_2	(2 << 24)
+#define FILCLKSEL_FILCLK3_3	(3 << 24)
+#define FILCLKSEL_FILCLK4_0	(0 << 32)
+#define FILCLKSEL_FILCLK4_1	(1 << 32)
+#define FILCLKSEL_FILCLK4_2	(2 << 32)
+#define FILCLKSEL_FILCLK4_3	(3 << 32)
+#define FILCLKSEL_FILCLK5_0	(0 << 40)
+#define FILCLKSEL_FILCLK5_1	(1 << 40)
+#define FILCLKSEL_FILCLK5_2	(2 << 40)
+#define FILCLKSEL_FILCLK5_3	(3 << 40)
+#define FILCLKSEL_FILCLK6_0	(0 << 48)
+#define FILCLKSEL_FILCLK6_1	(1 << 48)
+#define FILCLKSEL_FILCLK6_2	(2 << 48)
+#define FILCLKSEL_FILCLK6_3	(3 << 48)
+#define FILCLKSEL_FILCLK7_0	(0 << 56)
+#define FILCLKSEL_FILCLK7_1	(1 << 56)
+#define FILCLKSEL_FILCLK7_2	(2 << 56)
+#define FILCLKSEL_FILCLK7_3	(3 << 56)
+/* Register for setting the mode of ETH MII / RGMII */
+#define ETH_MII_0_MII		(1 << 0)
+#define ETH_MII_1_MII		(1 << 1)
+
+#define	PFC_SET_TBL_NUM		(11)
+#define	PFC_OFF				(0)
+#define PFC_ON				(1)
+
+#define PFC_MUX_TBL_NUM		(4)
+#define PFC_QSPI_TBL_NUM	(3)
+#define PFC_SD_TBL_NUM		(4)
+
+typedef struct {
+	int			flg;
+	uintptr_t	reg;
+	uint8_t		val;
+} PFC_REG_UINT8;
+
+typedef struct {
+	int			flg;
+	uintptr_t	reg;
+	uint32_t	val;
+} PFC_REG_UINT32;
+
+typedef struct {
+	int			flg;
+	uintptr_t	reg;
+	uint64_t	val;
+} PFC_REG_UINT64;
+
+
+typedef struct {
+	PFC_REG_UINT8	pmc;
+	PFC_REG_UINT32	pfc;
+	PFC_REG_UINT64	iolh;
+	PFC_REG_UINT64	pupd;
+	PFC_REG_UINT64	sr;
+	PFC_REG_UINT64	ien;
+} PFC_REGS;
+
+
+#endif	/* __PFC_REGS_H__ */
diff --git a/board/renesas/vkrzg2lc/vkrzg2lc.c b/board/renesas/vkrzg2lc/vkrzg2lc.c
new file mode 100644
index 0000000000..1d6b4e0669
--- /dev/null
+++ b/board/renesas/vkrzg2lc/vkrzg2lc.c
@@ -0,0 +1,296 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include "pfc_regs.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0         (PFC_BASE + 0x300c)
+#define I2C_CH1         (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010 + n)      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120 + n * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210 + n)      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440 + n * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810 + n)      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 43, 3)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 42, 0)
+#define PORT_USB1_OVRCUR    P( 42, 1)
+
+
+/* WDT */
+#define WDT_INDEX       0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xcc, 0x2b, 0x04, 0x32, 0x00, 0x1a, 0x5f, 0x12, 0x90, 0x79,
+    0x02, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xbf, 0x3f, 0x30, 0x90, 0x86,
+    0x80, 0xb2, 0x05, 0xc4, 0x9c
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for ETH0 */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30001;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;    
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+            ;
+
+    *(volatile u32 *)(RPC_CMNCR) = 0x01FFF300;
+}
+
+
+int board_led_init(void)
+{
+    /* RED LED: P8_2 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    //gpio_set(PORT_LED_R, 1);
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P42_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC1);
+
+    /* set P42_1 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC1);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int off, retval = 0;
+    struct udevice *iic_dev;
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, 1, &iic_dev);
+
+    if (retval == 0)
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+    /* Read Mac Address and set*/
+    retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_R, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/cmd/Kconfig b/cmd/Kconfig
index d561f3be8d..80d424be5d 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -1,5 +1,13 @@
 menu "Command line interface"
 
+menu "Renesas specific commands"
+config CMD_CM33
+	bool "RZ/G2L CM33 commands"
+	help
+	  Commands used to enable and control the embedded CM33 in the RZ/G2LC.
+
+endmenu
+
 config CMDLINE
 	bool "Support U-Boot commands"
 	default y
diff --git a/cmd/Makefile b/cmd/Makefile
index 4044ab189a..2dfbeaf8ae 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -39,6 +39,7 @@ obj-$(CONFIG_CMD_BUTTON) += button.o
 obj-$(CONFIG_CMD_CACHE) += cache.o
 obj-$(CONFIG_CMD_CBFS) += cbfs.o
 obj-$(CONFIG_CMD_CLK) += clk.o
+obj-$(CONFIG_CMD_CM33) += cm33.o
 obj-$(CONFIG_CMD_CLS) += cls.o
 obj-$(CONFIG_CMD_CONFIG) += config.o
 obj-$(CONFIG_CMD_CONITRACE) += conitrace.o
diff --git a/cmd/cm33.c b/cmd/cm33.c
new file mode 100644
index 0000000000..d7d6914b8f
--- /dev/null
+++ b/cmd/cm33.c
@@ -0,0 +1,131 @@
+#include <common.h>
+#include <command.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define CPG_SIPLL3_MON	(*(volatile u32 *)0x1101013C)	// PLL3 (SSCG) Monitor Register
+#define CPG_CLKON_CM33	(*(volatile u32 *)0x11010504)	// Clock Control Register Cortex-M33
+#define CPG_CLKMON_CM33	(*(volatile u32 *)0x11010684)	// Clock Monitor Register Cortex-M33
+#define CPG_RST_CM33	(*(volatile u32 *)0x11010804)	// Reset Control Register Cortex-M33
+#define CPG_RSTMON_CM33	(*(volatile u32 *)0x11010984)	// Reset Monitor Register Cortex-M33
+
+#define SYS_CM33_CFG0	(*(volatile u32 *)0x11020804)	// CM33 Config Register0
+#define SYS_CM33_CFG1	(*(volatile u32 *)0x11020808)	// CM33 Config Register1
+#define SYS_CM33_CFG2	(*(volatile u32 *)0x1102080C)	// CM33 Config Register2
+#define SYS_CM33_CFG3	(*(volatile u32 *)0x11020810)	// CM33 Config Register3
+#define SYS_CM33_CTL	(*(volatile u32 *)0x11020818)	// CM33 Control Register
+#define SYS_LSI_MODE	(*(volatile u32 *)0x11020A00)	// LSI Mode Signal Register
+#define SYS_LP_CM33CTL1	(*(volatile u32 *)0x11020D28)	// Lowpower Sequence CM33 Control Register1
+
+static void cm33_boot_normal_mode()
+{
+	// Supply clock to CM33_CLKIN
+	CPG_CLKON_CM33 = 0x00010001;
+
+	// Poll CPG_CLKMON_CM33 to confirm that CM33_CLKIN clock is supplied
+	while (CPG_CLKMON_CM33 != 0x1)
+		mdelay(10);
+
+	// Stop the reset signals (released from the reset state)
+	CPG_RST_CM33 = 0x00070007;
+
+	// Poll CPG_RSTMON_CM33 to confirm that all the reset signals are not applied
+	while(CPG_RSTMON_CM33 != 0)
+		mdelay(10);
+}
+
+static void cm33_boot_debug_mode()
+{
+	// Supply clock to CM33_TSCLK and CM33_CLKIN
+	CPG_CLKON_CM33 = 0x00030003;
+
+	// Poll CPG_CLKMON_CM33 to confirm that both CM33_TSCLK and CM33_CLKIN clock are supplied
+	while (CPG_CLKMON_CM33 != 0x3)
+		mdelay(10);
+
+	// Set DEBUGQREQn bit of SYS_LP_CM33CTL1 to 1
+	SYS_LP_CM33CTL1 = 0x00001100;
+
+	// Poll SYS_LP_CM33CTL1 to check if DEBUGQACCEPTn bit becomes 1
+	// Fixme. Lacking of SYS_LP_CM33CTL1.DEBUGQACCEPTn info
+
+	// Set FETCHCNT bit of SYS_CM33_CTL register to 1
+	SYS_CM33_CTL = 0x00000001;
+
+	// Stop the reset signals (released from the reset state)
+	CPG_RST_CM33 = 0x00070007;
+
+	// Poll CPG_RSTMON_CM33 to confirm that all the reset signals are not applied
+	while (CPG_RSTMON_CM33 != 0)
+		mdelay(10);
+
+	// Set FETCHCNT bit of SYS_CM33_CTL register to 0
+	SYS_CM33_CTL = 0x00000000;
+}
+
+void cm33_start(u8 debug, u32 s_addr, u32 ns_addr)
+{
+	// Check if the SSCG PLL3 is ON or not
+	if ((CPG_SIPLL3_MON & 0x1) == 0x1) {
+		SYS_CM33_CFG0 = 0x00103CE5;
+		SYS_CM33_CFG1 = 0x00103CE5;
+	} else {
+		SYS_CM33_CFG0 = 0x00003D08;
+		SYS_CM33_CFG1 = 0x00003D08;
+	}
+
+	// Set the secure vector address of Cortex-M33
+	SYS_CM33_CFG2 = s_addr;
+
+	// Set the non secure vector address of Cortex-M33
+	SYS_CM33_CFG3 = ns_addr;
+
+	// Start the CM33 propram in normal/debug mode
+	debug ? cm33_boot_debug_mode() : cm33_boot_normal_mode();
+}
+
+int do_cm33(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 s_addr, ns_addr;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	if (strcmp(argv[1], "start_normal") == 0) {
+		/* two addresses are required */
+		if (argc < 4)
+			goto usage;
+
+		s_addr = simple_strtoul(argv[2], NULL, 16);
+		ns_addr = simple_strtoul(argv[3], NULL, 16);
+		cm33_start(0, s_addr, ns_addr);
+	} else if (strcmp(argv[1], "start_debug") == 0) {
+		/* two addresses are required */
+		if (argc < 4)
+			goto usage;
+
+		s_addr = simple_strtoul(argv[2], NULL, 16);
+		ns_addr = simple_strtoul(argv[3], NULL, 16);
+		cm33_start(1, s_addr, ns_addr);
+	} else
+		goto usage;
+
+	return 0;
+
+usage:
+	return CMD_RET_USAGE;
+}
+
+static char cm33_help_text[] =
+	"\n\tstart_normal [s_addr] [ns_addr] - Reset and start CM33 in normal mode with firmware\n"
+	"\t\t\tlocated at address [s_addr] (secure) and [ns_addr] (non secure)\n"
+	"\tstart_debug [s_addr] [ns_addr] - Reset and start CM33 in debug mode with firmware\n"
+	"\t\t\tlocated at address [s_addr] (secure) and [ns_addr] (non secure)\n"
+	"";
+
+U_BOOT_CMD(
+	cm33, CONFIG_SYS_MAXARGS, 1, do_cm33,
+	"Control CM33 CPU", cm33_help_text
+);
diff --git a/configs/vkrzg2lc-sf_defconfig b/configs/vkrzg2lc-sf_defconfig
new file mode 100644
index 0000000000..7c5d3e30ae
--- /dev/null
+++ b/configs/vkrzg2lc-sf_defconfig
@@ -0,0 +1,106 @@
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKRZG2LC=y
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_SPL=n
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk1p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_EEPROM=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_OFFSET=0x1FFE000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2lc_defconfig b/configs/vkrzg2lc_defconfig
new file mode 100644
index 0000000000..87d3ce369a
--- /dev/null
+++ b/configs/vkrzg2lc_defconfig
@@ -0,0 +1,107 @@
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKRZG2LC=y
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_SPL=n
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_EEPROM=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=2
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index f4a370df10..52853fef47 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -159,11 +159,11 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("mx25u12835f", 0xc22538, 0, 64 * 1024, 256, SECT_4K) },
 	{ INFO("mx25l12855e", 0xc22618, 0, 64 * 1024, 256, 0) },
 	{ INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("mx25u25635f", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("mx25u25645g", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx25v8035f",  0xc22314, 0, 64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25r1635f",  0xc22815, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25l25655e", 0xc22619, 0, 64 * 1024, 512, 0) },
-	{ INFO("mx66l51235l", 0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
+	{ INFO("mx25l51245g", 0xc2201a, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx66u51235f", 0xc2253a, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx66u2g45g",  0xc2253c, 0, 64 * 1024, 4096, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx66l1g45g",  0xc2201b, 0, 64 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index b1b1fa5080..847bcccb4a 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -245,6 +245,7 @@ static int rtl8211f_config(struct phy_device *phydev)
 	phy_write(phydev, MDIO_DEVAD_NONE,
 		  MIIM_RTL8211F_PAGE_SELECT, 0xd04);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x10, 0x617f);
+        phy_write(phydev, MDIO_DEVAD_NONE, 0x11, 0x0000); /*Disable EEE LED indication*/
 	phy_write(phydev, MDIO_DEVAD_NONE,
 		  MIIM_RTL8211F_PAGE_SELECT, 0x0);
 
diff --git a/include/configs/vkrzg2lc.h b/include/configs/vkrzg2lc.h
new file mode 100644
index 0000000000..a5f11736b1
--- /dev/null
+++ b/include/configs/vkrzg2lc.h
@@ -0,0 +1,161 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VLRZG2LC_H
+#define __VLRZG2LC_H
+
+#include <asm/arch/rmobile.h>
+
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+//#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+//#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    0
+
+#define ETHER_EEPROM_ADDR     250 /* MAC address offset in EEPROM */
+//#define ETHER_DEFAULT_MACADDR   "00:12:F0:32:87:4F"
+
+
+#define DEFAULT_MMC_UENV_ARGS \
+    MMC_FDT_OVERLAY_SETTING \
+    NET_FDT_OVERLAY_SETTING \
+    "boardID=vkrzg2lc\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "loadbootenv=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "tftpdir=vkrzg2lc\0" \
+    "netloadbootenv=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "netenvboot=" \
+        "if run netloadbootenv; then " \
+            "echo Loaded env from ${bootenvfile};" \
+            "run importbootenv;" \
+        "else " \
+            "echo tftp server not found;" \
+        "fi;\0" \
+    "envboot=mmc dev ${mmcdev}; " \
+        "if mmc rescan; then " \
+            "echo SD/MMC found on device ${mmcdev};" \
+            "if run loadbootenv; then " \
+                "echo Loaded env from ${bootenvfile};" \
+                "run importbootenv;" \
+            "else " \
+                "echo Try loaded env from network;" \
+                "run netenvboot;" \
+            "fi;" \
+        "else " \
+            "echo Try loaded env from network;" \
+            "run netenvboot;" \
+        "fi;\0"
+
+#define MMC_BOOT_UENV  "run envboot;"
+#define DEFAULT_MMC_RZG2LC_ARGS  DEFAULT_MMC_UENV_ARGS
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZG2LC_ARGS \
+    "fdtfile=" CONFIG_DEFAULT_FDT_FILE "\0" \
+    "image=Image \0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+    "dtb_addr=0x48000000 \0" \
+    "image_addr=0x48080000 \0" \
+    "mmcbootargs=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "loadimage=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadfdt=echo loading ${fdtfile};fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "mmcload=mmc dev ${mmcdev};run loadfdt;run loadimage;run mmcbootargs \0" \
+    "bootimage=run mmcload; booti $image_addr - $dtb_addr \0" \
+    "netrootfs=/nfs/vkrzg2lc\0" \
+    "bootargs_net=setenv bootargs root=/dev/nfs ip=dhcp rw nfsroot=${serverip}:${netrootfs},vers=4,tcp\0" \
+    "netload=tftp $dtb_addr $serverip:${tftpdir}/$fdtfile; run bootargs_net;\0" \
+    "netloadimage=tftp $image_addr $serverip:${tftpdir}/$image; run bootargs_net;\0" \
+    "netboot=run netenvboot; run netload; run netloadimage; booti ${image_addr} - ${dtb_addr}\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "ipaddr=192.168.2.150\0"
+
+#include "vkrzg2lc_overlay.h"
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define CONFIG_BOOTCOMMAND      \
+        MMC_BOOT_UENV           \
+        MMC_BOOT_WITH_FDT_OVERLAY \
+        "run bootimage"
+
+#else
+#define CONFIG_BOOTCOMMAND  \
+    MMC_BOOT_UENV
+#endif
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VLRZG2LC_H */
diff --git a/include/configs/vkrzg2lc_overlay.h b/include/configs/vkrzg2lc_overlay.h
new file mode 100644
index 0000000000..20095b3ce6
--- /dev/null
+++ b/include/configs/vkrzg2lc_overlay.h
@@ -0,0 +1,75 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VKRZG2LC_FDT_OVERLAY_H
+#define __VKRZG2LC_FDT_OVERLAY_H
+
+#define GET_OVERLAY_APPLY(dtbo_name)          \
+	"echo Applying DT overlay: " dtbo_name " ;"  \
+	"fatload mmc ${mmcdev}:${mmcpart} ${dtbo_addr} ${overlaydir}/" dtbo_name "; " \
+	"fdt addr ${dtb_addr}; " \
+	"fdt apply ${dtbo_addr}; "
+
+#define GET_NET_OVERLAY_APPLY(dtbo_name)          \
+	"echo Applying DT overlay: " dtbo_name "; "  \
+	"tftp ${dtbo_addr} $serverip:${tftpdir}/${overlaydir}/" dtbo_name "; " \
+	"fdt addr ${dtb_addr}; " \
+	"fdt apply ${dtbo_addr}; "
+
+#define MMC_RUN_FDT_OVERLAY       \
+	"fdt addr ${dtb_addr}; "      \
+	"fdt resize 0x10000; "        \
+	"if env exists fdt_extra_overlays && test -n $fdt_extra_overlays ; then " \
+		"for dtbo_file in ${fdt_extra_overlays};  do "  \
+			GET_OVERLAY_APPLY( "${dtbo_file}" )         \
+		"done; "                  \
+	"fi;"
+
+#define NET_RUN_FDT_OVERLAY       \
+	"fdt addr ${dtb_addr}; "      \
+	"fdt resize 0x10000; "        \
+	"if env exists fdt_extra_overlays && test -n $fdt_extra_overlays ; then " \
+		"for dtbo_file in ${fdt_extra_overlays}; do " \
+			GET_NET_OVERLAY_APPLY( "${dtbo_file}" )         \
+		"done; "                  \
+	"fi;"
+
+
+#define MMC_FDT_OVERLAY_SETTING                  \
+	"dtbo_addr=0x48010000\0"                     \
+	"overlaydir=overlays\0"                      \
+	"mmcbootdto=echo Booting from mmc ...; "     \
+		"run mmcbootargs; "                      \
+		"if run loadfdt; then "                  \
+			MMC_RUN_FDT_OVERLAY                  \
+			"booti ${image_addr} - ${dtb_addr}; "  \
+		"else "                                  \
+			"echo WARN: Cannot load the DT; "    \
+		"fi;\0"
+
+#define NET_FDT_OVERLAY_SETTING              \
+	"netbootdto=echo Booting from net ...; " \
+	"if run netload; then "                  \
+		NET_RUN_FDT_OVERLAY                  \
+		"run netloadimage;"					 \
+		"booti ${image_addr} - ${dtb_addr}; "  \
+	"else "                                  \
+		"echo WARN: Cannot load the DT; "    \
+	"fi;\0"
+
+ #define MMC_BOOT_WITH_FDT_OVERLAY          \
+	 "mmc dev ${mmcdev};"                   \
+	 "if mmc rescan; then "                 \
+	 	"if run loadimage; then "           \
+			"run mmcbootdto; "              \
+		"else  "                            \
+			"run netbootdto; " \
+		"fi; "                              \
+	"else  "                            	\
+		"run netbootdto; "	\
+	"fi;\0"
+
+#define   VEKATECH_UENV_FDTO_SUPPORT
+
+#endif  /* __VKRZG2LC_FDT_OVERLAY_H */
-- 
2.34.1

